\section{CLAW abstraction}


\subsection{Column model abstraction}

The \lstinline!parallelize! directive is used to parallelize a column based
algorithm. In weather prediction models, the physical parametrization are column
independent problem. This means that the algorithm to compute the different
outputs, can be defined with a single do statement iterating over the level of
the column.
To parallelize efficiently this column computation over the domain, use this
directive.
The \lstinline!parallelize! directive is local to a subroutine. The algorithm
for the column computation must be enclosed in a subroutine.

\begin{lstlisting}
!$claw define dimension dim_id(lower_bound:upper_bound) &
[!$claw define dimension dim_id(lower_bound:upper_bound) &] ...
!$claw parallelize [data(data(var_1[,var_2] ...)] [over (dim_id|:[,dim_id|:] ...)]
\end{lstlisting}

\textbf{Options and details}
\begin{itemize}
\item \textit{define dimension}: Define a new dimension on which the column
model will be parallelized. The lower bound and upper bound of the defined
dimension can be either an integer constant or an integer variable. If a
variable if given, it will be added in order to the signature of the subroutine
as an \lstinline!INTENT(IN)! parameter.
\item \textit{data}: Define a list of variable to be promoted and bypass the
automatic deduction.
\item \textit{over}: Define the place of the new dimensions for the promotion of
the variables. The \lstinline!:! sign reflects the position of the current
dimensions.
\end{itemize}

If the \lstinline!data! clause is omitted, the promotion of variables is done as
follows:
Array variables declared with the \lstinline!INOUT! or \lstinline!OUT! intent
will be automatically promoted with the defined dimensions. The dimensions are
added on the left-side with the definition order.
In function of the target, intermediate scalar variable may also be promoted.
Scalar variable placed on the lhs of an assignment statement will be promoted
if the rhs references any variables (not a constant).
All the array references in the subroutine are promoted as well. If the
\lstinline!over! clause is omitted, the references are promotted with the
defined dimensions added at the beginning from left to right. The
\lstinline!over! clause allows to change this behavior and to place the new
dimensions where needed.

As the subroutine/function signature is updated by the \lstinline!parallelize! 
directive with new dimensions, the call graph that leads to this 
subroutine/function must be updated as well. For this purpose, the clause 
\lstinline!forward! allows to replicated the change along the call graph. 
Each subroutine/function along the call graph must be decorated with this
directive.

\begin{lstlisting}
!$claw parallelize forward
CALL one_columne_fct(x,y,z)
\end{lstlisting}

The first function call in the call graph might be an iteration over several
column to reproduce the algorithm on the grid. If the directive with the 
\lstinline!forward! clause is placed just before one or several nested do
statements with a function call, the corresponding do statements will be 
removed and the function call updated accordingly. 

\begin{lstlisting}
!$claw parallelize forward
DO i=istart, iend
  CALL one_columne_fct(x,y(i,:),z(i,:))
END DO
\end{lstlisting}






\textbf{Code example}\\
\label{parallelize1}
Simple example of a column model wrapped into a subroutine and parallelize with
CLAW.

Original code
\lstinputlisting[frame=rlbt,language=Fortran]{./code_samples/parallelize1/main.f90}
\lstinputlisting[frame=rlbt,language=Fortran]{./code_samples/parallelize1/mo_column.f90}

Transformed code\\
Only the code of the module is shown as it is the only one which changes.\\

CLAW generated code for GPU target with OpenACC accelerator directive language.
\lstinputlisting[frame=rlbt,language=Fortran]{./code_samples/parallelize1/mo_column_gpu_openacc.f90}

CLAW generated code for CPU target with no accelerator directive language.
\lstinputlisting[frame=rlbt,language=Fortran]{./code_samples/parallelize1/mo_column_cpu_none.f90}

Compilation with the CLAW Fortran Compiler
\begin{lstlisting}
clawfc --target=gpu --directive=openacc -o mo_column.claw.f90 mo_column.f90
clawfc -o main.claw.f90 main.f90
\end{lstlisting}

\subsection{K caching (column caching)}
\begin{lstlisting}
!$claw kcache data(var_1[,var_2] ...) [offset(offset_1[,offset_2] ...)]] [init] [private]
\end{lstlisting}

In memory-bound problem, it might be useful to cache array values used several
times during the current do statement iteration or for the next one.

The \textbf{kcache} directive is applied in a limited do statement block. It
will cache the corresponding assigned value and update the array index in the
block according to the given plus/minus offsets. If the array referenced in the
data clause is assigned in the block, the caching will take its place (see
example \ref{kcache1}). Otherwise, an assignment statement is created to start
the caching (see example \ref{kcache2}).

If the offset values are omitted, there are inferred from the dimension of the
variable to be cached and set to 0.

\textbf{Options and details}
\begin{itemize}
\item \textit{data}: The data clause specifies which array will be impacted by
the column caching transformation. List of array identifiers.
\item \textit{offset}: Integer value separated by a comma that represents the
offset at each dimension.
\item \textit{init}: If the \textit{init} clause is specified, the cache
variable will be initialized with the corresponding array value at the given
offset during the 1st loop iteration.
\item \textit{private}: it declares that a copy of each item on the list will
be created for each parallel gang on the accelerator. The list is the one
specified on the \textit{data} clause.
\end{itemize}

\textbf{Code example}\\
\label{kcache1}
Where caching takes assignment place and \lstinline!init! clause.

Original code
\begin{lstlisting}[language=Fortran]
DO j1 = k1start, k1end
  array_u6(j1,k3end) = pc1(j1,kend) * p2(j1)
ENDDO

DO j3 = k3start + 1, k3end
  DO j1 = k1start, k1end
    ! More computation here with others variables

    value1 = 1.0_dp / (1.0_dp - p2(j1) * (pc2(j1,j3) * array6(j1,j3-1)  &
                                     +  pc2(j1,j3) * array8(j1,j3-1) ))
    value2 = p2(j1) * (pc2(j1,j3) * array6(j1,j3-1)                     &
                      + pc2(j1,j3) * array8(j1,j3-1))
    value6 = p1(j1) * (pc2(j1,j3) * array6(j1,j3-1)                     &
                       +pc2(j1,j3) * array8(j1,j3-1))
	!$claw kcache data(array6) offset(0 -1) init
    array6(j1,j3) = p2(j1) * pc1(j1,j3)                                 &
                    + value2 * array8(j1,j3) + value6 * array8(j1,j3)
    array8(j1,j3) = p2(j1) * pc1(j1,j3)                                 &
                    + value6 * array2(j1,j3) + value7 * array4(j1,j3)
  END DO
END DO
\end{lstlisting}


Transformed code
\begin{lstlisting}[language=Fortran]
DO j1 = k1start, k1end
  array_u6(j1,k3end) = pc1(j1,kend) * p2(j1)
ENDDO

DO j1 = k1start, k1end
  DO j3 = k3start + 1, k3end
    IF (j3 = k3start + 1) THEN
      array6_k_m1 = array6(j1,j3-1)
      array8_k_m1 = array8(j1,j3-1)
    END IF
    ! More computation here with others variables

    value1 = 1.0_dp / (1.0_dp - p2(j1) * (pc2(j1,j3) * array6_k_m1    &
                                     +  pc2(j1,j3) * array8_k_m1 ))
    value2 = p2(j1) * (pc2(j1,j3) * array6_k_m1                       &
                      + pc2(j1,j3) * array8_k_m1
    value6 = p1(j1) * (pc2(j1,j3) * array6_k_m1                       &
                       +pc2(j1,j3) * array8_k_m1
	!$claw kcache data(array6, array8) offset(0 -1) init
	array6_k_m1 = p2(j1) * pc1(j1,j3)                                 &
                    + value2 * array8(j1,j3) + value6 * array8(j1,j3)
    array6(j1,j3) = array6_k_m1
    array8_k_m1 = p2(j1) * pc1(j1,j3)                                 &
                    + value6 * array2(j1,j3) + value7 * array4(j1,j3)
    array8(j1,j3) = array8_k_m1
  END DO
END DO
\end{lstlisting}

More code examples in the appendix. Example with assignment created during the
transformation (see example \ref{kcache2}). Example with \lstinline!init! and
\lstinline!private! clause (see example \ref{kcache3}).

\subsection{On-the-fly computation (array access to function call)}
\begin{lstlisting}
!$claw call array_name=function_call(arg_list)
\end{lstlisting}

Sometimes, replacing access to pre-computed arrays with computation on-the-fly
can increase the performance. It can reduce the memory access for memory-bound
kernel and exploit some unused resources to execute the computation.

This transformation is local to the current do statement. Array access from the
directive will be replaced.

\textbf{Options and details}
\begin{itemize}
\item \textit{array\_name}: Array identifier. References to this array will be
replaced by the function call in the current structured block.
\item \textit{function\_call}: Name of the function provided by the user to
compute the value. Return value must be of the same type as accessed value.
\item \textit{arg\_list}: Comma separated list of arguments to be passed to
the function call.
\end{itemize}
